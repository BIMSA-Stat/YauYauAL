% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrap_outiu_function.R
\name{wrap_outiu_function}
\alias{wrap_outiu_function}
\title{Function to Wrap and Update Output \code{Iu} with Progress Bar}
\usage{
wrap_outiu_function(s, NtNtau, Ntau, Nt, Dim, y, h, Lambda, B, Ns, NormalizedExp, DST_Solver)
}
\arguments{
\item{s}{A numeric matrix of size \code{(number of sequences x Dim)} representing input state sequences.}

\item{NtNtau}{Integer. The total number of time steps, including the \code{Ntau} steps.}

\item{Ntau}{Integer. The number of tau steps in the iterative process.}

\item{Nt}{Integer. The number of regular time steps within each tau interval.}

\item{Dim}{Integer. The dimension of the state space.}

\item{y}{A numeric matrix representing observed values at each time step.}

\item{h}{A user-defined function that computes the relationship between \code{s} and the observations \code{y}.
It should accept a numeric vector and return a numeric vector.}

\item{Lambda}{A numeric vector of parameters used within the \code{DST_Solver} function.}

\item{B}{A numeric matrix used as a coefficient matrix in the \code{DST_Solver} function.}

\item{Ns}{Integer. The sample size or scaling parameter used in the \code{DST_Solver}.}

\item{NormalizedExp}{A function that normalizes exponential values for the input sequences.}

\item{DST_Solver}{A function that solves a differential equation given \code{Dim}, \code{Lambda}, \code{B},
and other inputs. It should return a numeric vector of the same length as the input.}
}
\value{
A numeric matrix \code{Iu} of size \code{NtNtau x Dim}, where each row corresponds to a time step and each
column corresponds to a dimension of the state space. The values represent the updated state trajectory.
}
\description{
This function computes and updates a matrix \code{Iu} based on a sequence of input vectors, iterative updates,
and transformations. It uses a progress bar to display the computation progress and performs differential
equation solving through the \code{DST_Solver} function while normalizing values using the \code{NormalizedExp} function.
}
\details{
The function iteratively updates the \code{Iu} matrix as follows:
\enumerate{
\item Initializes the state vector \code{U} using an exponential function and normalizes it.
\item Updates \code{U} at each time step by applying the \code{DST_Solver} and the observation function \code{h}.
\item Computes weighted sums of \code{U} and \code{s} to populate the \code{Iu} matrix.
\item Utilizes a progress bar to display the computation progress for user feedback.
}

The function ensures numerical stability by normalizing \code{U} at each step and handles multi-dimensional
state spaces by processing each dimension independently.
}
\examples{
# Example setup
s <- matrix(runif(100), nrow = 10, ncol = 10)
NtNtau <- 50
Ntau <- 10
Nt <- 5
Dim <- 10
y <- matrix(runif(100), nrow = Ntau, ncol = Dim)

# Define example functions
h <- function(x) x^2
NormalizedExp <- function(x) exp(x - max(x)) / sum(exp(x - max(x)))
DST_Solver <- function(Dim, Lambda, B, U, Ns) {
  U * Lambda / sum(Lambda)
}

# Define parameters
Lambda <- runif(Dim)
B <- diag(Dim)
Ns <- 10

# Compute Iu
Iu <- wrap_outiu_function(s, NtNtau, Ntau, Nt, Dim, y, h, Lambda, B, Ns, NormalizedExp, DST_Solver)
print(Iu)

}
