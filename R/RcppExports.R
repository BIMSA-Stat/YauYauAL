# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name DST_Solver
#' @title Solve a System Using the Discrete Sine Transform (DST-II)
#' @description
#' This function solves a system using the Discrete Sine Transform (DST-II).
#' It computes transformations, applies scaling with eigenvalues, and normalizes the result.
#'
#' @usage
#' DST_Solver(Dim, Lambda, B, U, Ns)
#'
#' @param Dim Integer. The dimension of the problem. For example, \code{Dim = 1} solves a one-dimensional problem.
#' @param Lambda A numeric vector of type \code{Eigen::VectorXd} representing scaling factors (eigenvalues).
#' @param B A sparse matrix of type \code{Eigen::SparseMatrix<double>} representing a linear operator in the system.
#' @param U A numeric vector of type \code{Eigen::VectorXd} representing the initial state vector.
#' @param Ns Integer. The size of each segment to be processed by DST-II.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Computes the product \eqn{B \cdot U}, where \eqn{B} is a sparse matrix and \eqn{U} is the input vector.
#'   \item Applies the Discrete Sine Transform (DST-II) to the product.
#'   \item Scales the transformed values by dividing by the vector \eqn{\Lambda}.
#'   \item Applies DST-II again to the scaled values.
#'   \item Ensures all values in the result are non-negative and normalizes the vector so that its sum is 1.
#' }
#' It handles one-dimensional problems as a special case and generalizes to higher dimensions by processing segments independently.
#'
#' @return
#' A numeric vector of type \code{Eigen::VectorXd} representing the final normalized result after applying DST-II twice and scaling.
#'
#' @examples
#' library(Matrix)
#' Dim <- 1
#' Lambda <- c(1, 2, 3, 4)
#' B <- sparseMatrix(i = c(1, 2), j = c(1, 2), x = c(0.5, 0.75), dims = c(4, 4))
#' U <- c(1, 2, 3, 4)
#' Ns <- 4
#' result <- DST_Solver(Dim, Lambda, B, U, Ns)
#' print(result)
#'
#' @export
DST_Solver <- function(Dim, Lambda, B, U, Ns) {
    .Call(`_YauYauFilter_DST_Solver`, Dim, Lambda, B, U, Ns)
}

#' @name ExpandGrid
#' @title Generate a Grid of All Combinations of Input Sequence
#' @description
#' This function generates a grid by expanding the input sequence \code{s} across the specified 
#' number of dimensions (\code{Dim}). The resulting grid contains all possible combinations of the 
#' elements in \code{s}, repeated across \code{Dim} dimensions. The grid is filled column by column, 
#' with the last column cycling through the values in \code{s} the fastest.
#' @usage
#' ExpandGrid(Dim, s)
#' @param Dim Integer. The number of dimensions for the grid. For example, \code{Dim = 2} creates a 2D grid.
#' @param s A numeric vector (\code{NumericVector}) containing the values to expand into the grid.
#' @details
#' This function creates a numeric matrix where each row represents a unique combination of the elements 
#' in \code{s} distributed across \code{Dim} dimensions. The total number of rows in the resulting matrix 
#' is \eqn{\text{length}(s)^\text{Dim}}, and the number of columns is equal to \code{Dim}. 
#' The combinations are generated such that the first column cycles through all combinations the slowest, 
#' while the last column cycles the fastest.
#' @return
#' A numeric matrix (\code{NumericMatrix}) where each row represents a combination of values from 
#' \code{s} across \code{Dim} dimensions. 
#' rows and \code{Dim} columns.
#' @examples
#' # Generate a 3D grid using values from 1 to 4
#' s <- seq(1, 4, 1)
#' Dim <- 3
#' grid <- ExpandGrid(Dim, s)
#' print(grid)
#' @export
ExpandGrid <- function(Dim, s) {
    .Call(`_YauYauFilter_ExpandGrid`, Dim, s)
}

#' @name NormalizedExp
#' @title Normalized Exponential Function
#' @description
#' Computes the normalized exponential of a numeric vector. To prevent numerical overflow,
#' the input values are shifted by subtracting the maximum value of the vector. The function
#' then calculates the exponential of each shifted value and normalizes the result so that
#' the sum of the output vector equals 1. This is commonly used for probability distributions
#' or softmax operations in machine learning and numerical analysis.
#'
#' @usage
#' NormalizedExp(x)
#'
#' @param x A numeric vector of type \code{arma::vec}. Contains the values to be processed
#'          by the normalized exponential function.
#'
#' @details
#' The function performs the following steps:
#' \enumerate{
#'   \item Finds the maximum value in the input vector \code{x}, denoted as \code{max_x}.
#'   \item Shifts the input vector by subtracting \code{max_x}, creating a new vector \code{x_shifted}.
#'   \item Computes the element-wise exponential of \code{x_shifted}.
#'   \item Normalizes the exponential values by dividing by their sum, ensuring the output
#'         lies in the range \eqn{[0, 1]} and the sum of the vector equals 1.
#' }
#' This normalization is particularly useful in scenarios where probabilities or relative
#' importance need to be derived from raw scores or unnormalized values.
#'
#' @return
#' A numeric vector of type \code{arma::vec}, where each element is the normalized exponential
#' value of the corresponding input element. The sum of the output vector is guaranteed to be 1.
#'
#' @examples
#' # Example: Normalizing a vector using the normalized exponential function
#' x <- c(1, 2, 3, 4)
#' result <- NormalizedExp(x)
#' print(result)
#'
#' # Example: Handling a vector with large values
#' y <- c(1000, 1001, 1002)
#' result <- NormalizedExp(y)
#' print(result)
#'
#' @export
NormalizedExp <- function(x) {
    .Call(`_YauYauFilter_NormalizedExp`, x)
}

#' @name computeB
#' @title Compute Sparse Matrix B
#' @description
#' This function computes a sparse matrix \eqn{B} using input matrices, user-defined functions,
#' and sparse Kronecker-product-related operations. The matrix \eqn{B} is constructed by applying
#' transformations to input grid points and updating a diagonal matrix \eqn{Q} based on user-defined
#' functions and sparse matrices.
#'
#' @usage computeB(s, D_list, Dt, Ds, f, df, h)
#'
#' @param s A numeric matrix (\code{Eigen::MatrixXd}) representing grid points.
#'          Each row corresponds to a grid point, and each column corresponds to a dimension.
#' @param D_list A list of sparse matrices (\code{Eigen::SparseMatrix}) representing
#'               differential operators for each dimension.
#' @param Dt A numeric value specifying the time step parameter.
#' @param Ds A numeric value specifying the grid spacing parameter.
#' @param f A user-defined function applied to each row of \eqn{s}. It should return
#'          a numeric vector.
#' @param df A user-defined derivative function applied to each row of \eqn{s}.
#'           It should return a numeric vector.
#' @param h A user-defined function applied to each row of \eqn{s}. It contributes
#'          to the diagonal updates in matrix \eqn{Q}. It should return a numeric vector.
#'
#' @details
#' The function calculates the matrix \eqn{B} as follows:
#' \enumerate{
#'   \item Apply the user-defined function \eqn{f} to each row of \eqn{s} to compute
#'         the negated values stored in \eqn{p}.
#'   \item Construct a diagonal matrix \eqn{Q}, where each diagonal element is computed
#'         as the sum of the user-defined derivative function \eqn{df} and the inner product
#'         of the function \eqn{h} applied to the corresponding row of \eqn{s}.
#'   \item Update \eqn{Q} by adding contributions from \eqn{p} and the input list of
#'         sparse matrices \eqn{D_list}.
#'   \item Compute \eqn{B} as \eqn{I + Dt \cdot Q}, where \eqn{I} is an identity matrix.
#' }
#'
#' @return
#' A sparse matrix (\code{Eigen::SparseMatrix}) representing the computed \eqn{B} matrix.
#'
#' @export
computeB <- function(s, D_list, Dt, Ds, f, df, h) {
    .Call(`_YauYauFilter_computeB`, s, D_list, Dt, Ds, f, df, h)
}

#' @name computeLambda
#' @title Compute Lambda Vector
#' @description
#' Computes the Lambda vector using Kronecker products to construct a sparse matrix.
#' The Lambda vector represents scaled eigenvalues derived from the diagonal of the Kronecker sum
#' of a 1D Laplacian operator in multiple dimensions.
#'
#' @usage
#' computeLambda(Dim, Ns, Dt, Ds)
#'
#' @param Dim Integer. The dimension of the Kronecker product.
#' @param Ns Integer. The size of the grid in each dimension.
#' @param Dt Numeric. The time step size.
#' @param Ds Numeric. The space step size.
#'
#' @details
#' The function first computes a vector of eigenvalues \eqn{d} for a 1D Laplacian operator.
#' It then constructs a sparse matrix \eqn{D_\text{kron}} by summing the Kronecker products
#' of these eigenvalues across all dimensions. Finally, it computes the Lambda vector by scaling
#' the diagonal elements of \eqn{D_\text{kron}} using the parameters \code{Dt} and \code{Ds}.
#'
#' @return
#' A numeric vector of type \code{Eigen::VectorXd} containing the scaled eigenvalues (\code{Lambda}).
#' The length of the vector is \eqn{Ns^\text{Dim}}.
#'
#' @examples
#' Dim <- 3
#' Ns <- 4
#' Dt <- 0.01
#' Ds <- 0.5
#' Lambda <- computeLambda(Dim, Ns, Dt, Ds)
#' print(Lambda)
#'
#' @export
computeLambda <- function(Dim, Ns, Dt, Ds) {
    .Call(`_YauYauFilter_computeLambda`, Dim, Ns, Dt, Ds)
}

#' @name generateD
#' @title Generate Sparse Matrices Using Kronecker Products
#' @description
#' This function generates a list of sparse matrices based on the specified dimension (\code{Dim}),
#' grid size (\code{Ns}), and spacing parameter (\code{Ds}). These matrices are constructed using 
#' Kronecker products of identity matrices and sparse matrices representing differential operators. 
#' They are useful for discretizing high-dimensional differential operators on regular grids.
#' @usage
#' generateD(Dim, Ns, Ds)
#' @param Dim Integer. The number of dimensions of the problem. This determines the number of matrices generated.
#' @param Ns Integer. The size of the grid in each dimension.
#' @param Ds Numeric. The grid spacing parameter, which scales the off-diagonal values in the matrices.
#' @details
#' The function constructs one sparse matrix for each dimension. For each dimension, the following steps are performed:
#' \enumerate{
#'   \item Two identity matrices (\code{I1} and \code{I2}) are created based on the grid size and dimension index.
#'   \item A sparse matrix is generated to represent the discretized 1D operator, with off-diagonal values scaled by \code{0.5 / Ds}.
#'   \item The final sparse matrix for the dimension is constructed as a Kronecker product of these components.
#' }
#' The output is a list of sparse matrices, one for each dimension, which can be used to discretize high-dimensional problems.
#' @return
#' A list of sparse matrices of type \code{Eigen::SparseMatrix<double>}. Each matrix corresponds to one dimension
#' and represents a discretized operator for that dimension.
#' @examples
#' # Example: Generate sparse matrices for a 3D grid
#' Dim <- 3
#' Ns <- 4
#' Ds <- 0.5
#' D_list <- generateD(Dim, Ns, Ds)
#' # Check the structure of the first sparse matrix
#' print(D_list[[1]])
#' @export
generateD <- function(Dim, Ns, Ds) {
    .Call(`_YauYauFilter_generateD`, Dim, Ns, Ds)
}

#' Simulate State and Observations
#' 
#' @name Simulate_State_Obser
#' @title Simulate State and Observations
#' @param Dt Numeric. The time step size for the simulation.
#' @param Ntau Integer. The number of observation points.
#' @param NtNtau Integer. The total number of time steps in the simulation.
#' @param f Function. A user-provided function representing the state dynamics.
#' @param h Function. A user-provided function representing the observation model.
#' @param Dim Integer. The dimension of the system.
#' @param seed Nullable Integer. An optional random seed for reproducibility.
#' @return A list containing:
#' \item{x}{A matrix of the state trajectory over time.}
#' \item{y}{A matrix of the observations at specific time points.}
#' @description This function simulates the evolution of a system over time using the provided dynamics and observation models.
#' @export
Simulate_State_Obser <- function(Dt, Ntau, NtNtau, f, h, Dim, seed = NULL) {
    .Call(`_YauYauFilter_Simulate_State_Obser`, Dt, Ntau, NtNtau, f, h, Dim, seed)
}

